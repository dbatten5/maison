{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Maison","text":"<p>When developing a <code>python</code> application, e.g a command-line tool, it can be helpful to allow the user to set their own configuration options to allow them to tailor the tool to their needs. These options are typically set in files in the root of a project directory that uses the tool, for example in a <code>pyproject.toml</code> file.</p> <p><code>maison</code> aims to provide a simple and flexible way to read and validate those configuration options so that they may be used in the application.</p>"},{"location":"#installing","title":"Installing","text":"<pre><code>pip install maison\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>Suppose we have a <code>pyproject.toml</code> which looks like the following:</p> <pre><code>[tool.acme]\nfoo = \"bar\"\n</code></pre> <p>In order to read the value of <code>foo</code>, run the following:</p> <pre><code>from maison import ProjectConfig\n\nconfig = ProjectConfig(project_name=\"acme\")\nfoo_option = config.get_option(\"foo\")\n\nprint(foo_option)\n#&gt; \"bar\"\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#issues","title":"Issues","text":"<p>If you notice an issue with <code>maison</code> or would like to suggest a feature or just have a general question, please raise an issue on GitHub. If it's an issue that needs debugging please make sure to include the version of <code>maison</code> in the issue description. You can retrieve the version with the following:</p> <pre><code>pip freeze | grep maison\n</code></pre>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>If you would like to contribute to the repo, you would be most welcome. If you're tackling an existing issue please comment on the issue that you'd like to take it on. If it's a new feature/bug, please first raise an issue. There is also a <code>kanban</code> board here for more feature ideas.</p>"},{"location":"contributing/#local-development","title":"Local Development","text":"<p>In order to work on your contribution, you'll need to first fork the repo and then clone it to your local machine:</p> <pre><code>git clone git@github.com:&lt;your username&gt;/maison.git\ncd maison\n</code></pre> <p>You'll need <code>python</code> 3.8+ to run this package. You can follow the instructions here to install and use these versions.</p> <p>This package uses <code>poetry</code> to manage dependencies. Ensure you have <code>poetry</code> installed, instructions here and run:</p> <pre><code>poetry install\n</code></pre> <p>This will install the dependencies into a <code>.venv</code> virtual environment. You can activate the env with either <code>source .venv/bin/activate</code> or <code>poetry shell</code>.</p> <p>Next install the <code>pre-commit</code> hooks with:</p> <pre><code>pre-commit install\n</code></pre> <p>Nox is used to run tests, linters, type checkers etc. These are all run in the CI and on <code>git commit</code> but if you'd like to run them manually, you can do so with, eg:</p> <pre><code>nox --session=tests\n</code></pre> <p>This will run the tests for all versions of python.</p> <p>See here for more information on running <code>nox</code> locally.</p> <p>If you're making changes that will require updates to the documentation, please do so accordingly. Documentation lives in the <code>docs/</code> directory and can be served locally with:</p> <pre><code>mkdocs serve\n</code></pre> <p>See here for more information on working with <code>mkdocs</code>.</p> <p>Once you're ready with your shiny, TDD'd feature, commit, push, and open a pull request and I'll be happy to review. If you're having issues with any of this setup please do let me know and I'll try and help.</p>"},{"location":"reference/","title":"Reference","text":"<p>Defines the <code>ProjectConfig</code> and provides accessors to get config values.</p> Source code in <code>src/maison/config.py</code> <pre><code>class ProjectConfig:\n    \"\"\"Defines the `ProjectConfig` and provides accessors to get config values.\"\"\"\n\n    def __init__(\n        self,\n        project_name: str,\n        starting_path: Optional[Path] = None,\n        source_files: Optional[List[str]] = None,\n        config_schema: Optional[Type[ConfigSchema]] = None,\n        merge_configs: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize the config.\n\n        Args:\n            project_name: the name of the project, to be used to find the right section\n                in the config file\n            starting_path: an optional starting path to start the search for config\n                file\n            source_files: an optional list of source config filenames or absolute paths\n                to search for. If none is provided then `pyproject.toml` will be used.\n            config_schema: an optional `pydantic` model to define the config schema\n            merge_configs: an optional boolean to determine whether configs should be\n                merged if multiple are found\n        \"\"\"\n        self.source_files = source_files or [\"pyproject.toml\"]\n        self.merge_configs = merge_configs\n        self._sources = _collect_configs(\n            project_name=project_name,\n            source_files=self.source_files,\n            starting_path=starting_path,\n        )\n        self._config_dict = self._generate_config_dict()\n        self._config_schema = config_schema\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the __repr__.\n\n        Returns:\n            the representation\n        \"\"\"\n        return f\"&lt;class '{self.__class__.__name__}'&gt;\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the __str__.\n\n        Returns:\n            the representation\n        \"\"\"\n        return self.__repr__()\n\n    @property\n    def config_path(self) -&gt; Optional[Union[Path, List[Path]]]:\n        \"\"\"Return a list of the path(s) to the config source(s).\n\n        Returns:\n            `None` is no config sources have been found, a list of the found config\n            sources if `merge_configs` is `True`, or the path to the active config\n            source if `False`\n        \"\"\"\n        if len(self._sources) == 0:\n            return None\n\n        if self.merge_configs:\n            return self.discovered_config_paths\n\n        return self.discovered_config_paths[0]\n\n    @property\n    def discovered_config_paths(self) -&gt; List[Path]:\n        \"\"\"Return a list of the paths to the config sources found on the filesystem.\n\n        Returns:\n            a list of the paths to the config sources\n        \"\"\"\n        return [source.filepath for source in self._sources]\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Return a dict of all the config options.\n\n        Returns:\n            a dict of the config options\n        \"\"\"\n        return self._config_dict\n\n    @property\n    def config_schema(self) -&gt; Optional[Type[ConfigSchema]]:\n        \"\"\"Return the `config_schema`.\n\n        Returns:\n            the `config_schema`\n        \"\"\"\n        return self._config_schema\n\n    @config_schema.setter\n    def config_schema(self, config_schema: Type[ConfigSchema]) -&gt; None:\n        \"\"\"Set the `config_schema`.\"\"\"\n        self._config_schema = config_schema\n\n    def validate(\n        self,\n        config_schema: Optional[Type[ConfigSchema]] = None,\n        use_schema_values: bool = True,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Validate the configuration.\n\n        Warning:\n            Using this method with `use_schema_values` set to `True` will cast values to\n            whatever is defined in the schema. For example, for the following schema:\n\n                class Schema(ConfigSchema):\n                    foo: str\n\n            Validating a config with:\n\n                {\"foo\": 1}\n\n            Will result in:\n\n                {\"foo\": \"1\"}\n\n        Args:\n            config_schema: an optional `ConfigSchema` to define the schema. This\n                takes precedence over a schema provided at object instantiation.\n            use_schema_values: an optional boolean to indicate whether the result\n                of passing the config through the schema should overwrite the existing\n                config values, meaning values are cast to types defined in the schema as\n                described above, and default values defined in the schema are used.\n\n        Returns:\n            the config values\n\n        Raises:\n            NoSchemaError: when validation is attempted but no schema has been provided\n        \"\"\"\n        if not (config_schema or self.config_schema):\n            raise NoSchemaError\n\n        schema: Type[ConfigSchema] = config_schema or self.config_schema  # type: ignore\n\n        validated_schema = schema(**self._config_dict)\n\n        if use_schema_values:\n            self._config_dict = validated_schema.dict()\n\n        return self._config_dict\n\n    def get_option(\n        self, option_name: str, default_value: Optional[Any] = None\n    ) -&gt; Optional[Any]:\n        \"\"\"Return the value of a config option.\n\n        Args:\n            option_name: the config option for which to return the value\n            default_value: an option default value if the option isn't set\n\n        Returns:\n            The value of the given config option or `None` if it doesn't exist\n        \"\"\"\n        return self._config_dict.get(option_name, default_value)\n\n    def _generate_config_dict(self) -&gt; Dict[Any, Any]:\n        \"\"\"Generate the project config dict.\n\n        If `merge_configs` is set to `False` then we use the first config. If `True`\n        then the dicts of the sources are merged from right to left.\n\n        Returns:\n            the project config dict\n        \"\"\"\n        if len(self._sources) == 0:\n            return {}\n\n        if not self.merge_configs:\n            return self._sources[0].to_dict()\n\n        source_dicts = [source.to_dict() for source in self._sources]\n        return reduce(lambda a, b: deep_merge(a, b), source_dicts)\n</code></pre>"},{"location":"reference/#maison.config.ProjectConfig.config_path","title":"<code>config_path: Optional[Union[Path, List[Path]]]</code>  <code>property</code>","text":"<p>Return a list of the path(s) to the config source(s).</p> <p>Returns:</p> Type Description <code>Optional[Union[Path, List[Path]]]</code> <p><code>None</code> is no config sources have been found, a list of the found config</p> <code>Optional[Union[Path, List[Path]]]</code> <p>sources if <code>merge_configs</code> is <code>True</code>, or the path to the active config</p> <code>Optional[Union[Path, List[Path]]]</code> <p>source if <code>False</code></p>"},{"location":"reference/#maison.config.ProjectConfig.config_schema","title":"<code>config_schema: Optional[Type[ConfigSchema]]</code>  <code>property</code> <code>writable</code>","text":"<p>Return the <code>config_schema</code>.</p> <p>Returns:</p> Type Description <code>Optional[Type[ConfigSchema]]</code> <p>the <code>config_schema</code></p>"},{"location":"reference/#maison.config.ProjectConfig.discovered_config_paths","title":"<code>discovered_config_paths: List[Path]</code>  <code>property</code>","text":"<p>Return a list of the paths to the config sources found on the filesystem.</p> <p>Returns:</p> Type Description <code>List[Path]</code> <p>a list of the paths to the config sources</p>"},{"location":"reference/#maison.config.ProjectConfig.__init__","title":"<code>__init__(project_name, starting_path=None, source_files=None, config_schema=None, merge_configs=False)</code>","text":"<p>Initialize the config.</p> <p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>the name of the project, to be used to find the right section in the config file</p> required <code>starting_path</code> <code>Optional[Path]</code> <p>an optional starting path to start the search for config file</p> <code>None</code> <code>source_files</code> <code>Optional[List[str]]</code> <p>an optional list of source config filenames or absolute paths to search for. If none is provided then <code>pyproject.toml</code> will be used.</p> <code>None</code> <code>config_schema</code> <code>Optional[Type[ConfigSchema]]</code> <p>an optional <code>pydantic</code> model to define the config schema</p> <code>None</code> <code>merge_configs</code> <code>bool</code> <p>an optional boolean to determine whether configs should be merged if multiple are found</p> <code>False</code> Source code in <code>src/maison/config.py</code> <pre><code>def __init__(\n    self,\n    project_name: str,\n    starting_path: Optional[Path] = None,\n    source_files: Optional[List[str]] = None,\n    config_schema: Optional[Type[ConfigSchema]] = None,\n    merge_configs: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the config.\n\n    Args:\n        project_name: the name of the project, to be used to find the right section\n            in the config file\n        starting_path: an optional starting path to start the search for config\n            file\n        source_files: an optional list of source config filenames or absolute paths\n            to search for. If none is provided then `pyproject.toml` will be used.\n        config_schema: an optional `pydantic` model to define the config schema\n        merge_configs: an optional boolean to determine whether configs should be\n            merged if multiple are found\n    \"\"\"\n    self.source_files = source_files or [\"pyproject.toml\"]\n    self.merge_configs = merge_configs\n    self._sources = _collect_configs(\n        project_name=project_name,\n        source_files=self.source_files,\n        starting_path=starting_path,\n    )\n    self._config_dict = self._generate_config_dict()\n    self._config_schema = config_schema\n</code></pre>"},{"location":"reference/#maison.config.ProjectConfig.__repr__","title":"<code>__repr__()</code>","text":"<p>Return the repr.</p> <p>Returns:</p> Type Description <code>str</code> <p>the representation</p> Source code in <code>src/maison/config.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the __repr__.\n\n    Returns:\n        the representation\n    \"\"\"\n    return f\"&lt;class '{self.__class__.__name__}'&gt;\"\n</code></pre>"},{"location":"reference/#maison.config.ProjectConfig.__str__","title":"<code>__str__()</code>","text":"<p>Return the str.</p> <p>Returns:</p> Type Description <code>str</code> <p>the representation</p> Source code in <code>src/maison/config.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the __str__.\n\n    Returns:\n        the representation\n    \"\"\"\n    return self.__repr__()\n</code></pre>"},{"location":"reference/#maison.config.ProjectConfig.get_option","title":"<code>get_option(option_name, default_value=None)</code>","text":"<p>Return the value of a config option.</p> <p>Parameters:</p> Name Type Description Default <code>option_name</code> <code>str</code> <p>the config option for which to return the value</p> required <code>default_value</code> <code>Optional[Any]</code> <p>an option default value if the option isn't set</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>The value of the given config option or <code>None</code> if it doesn't exist</p> Source code in <code>src/maison/config.py</code> <pre><code>def get_option(\n    self, option_name: str, default_value: Optional[Any] = None\n) -&gt; Optional[Any]:\n    \"\"\"Return the value of a config option.\n\n    Args:\n        option_name: the config option for which to return the value\n        default_value: an option default value if the option isn't set\n\n    Returns:\n        The value of the given config option or `None` if it doesn't exist\n    \"\"\"\n    return self._config_dict.get(option_name, default_value)\n</code></pre>"},{"location":"reference/#maison.config.ProjectConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Return a dict of all the config options.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>a dict of the config options</p> Source code in <code>src/maison/config.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Return a dict of all the config options.\n\n    Returns:\n        a dict of the config options\n    \"\"\"\n    return self._config_dict\n</code></pre>"},{"location":"reference/#maison.config.ProjectConfig.validate","title":"<code>validate(config_schema=None, use_schema_values=True)</code>","text":"<p>Validate the configuration.</p> Warning <p>Using this method with <code>use_schema_values</code> set to <code>True</code> will cast values to whatever is defined in the schema. For example, for the following schema:</p> <pre><code>class Schema(ConfigSchema):\n    foo: str\n</code></pre> <p>Validating a config with:</p> <pre><code>{\"foo\": 1}\n</code></pre> <p>Will result in:</p> <pre><code>{\"foo\": \"1\"}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config_schema</code> <code>Optional[Type[ConfigSchema]]</code> <p>an optional <code>ConfigSchema</code> to define the schema. This takes precedence over a schema provided at object instantiation.</p> <code>None</code> <code>use_schema_values</code> <code>bool</code> <p>an optional boolean to indicate whether the result of passing the config through the schema should overwrite the existing config values, meaning values are cast to types defined in the schema as described above, and default values defined in the schema are used.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>the config values</p> <p>Raises:</p> Type Description <code>NoSchemaError</code> <p>when validation is attempted but no schema has been provided</p> Source code in <code>src/maison/config.py</code> <pre><code>def validate(\n    self,\n    config_schema: Optional[Type[ConfigSchema]] = None,\n    use_schema_values: bool = True,\n) -&gt; Dict[str, Any]:\n    \"\"\"Validate the configuration.\n\n    Warning:\n        Using this method with `use_schema_values` set to `True` will cast values to\n        whatever is defined in the schema. For example, for the following schema:\n\n            class Schema(ConfigSchema):\n                foo: str\n\n        Validating a config with:\n\n            {\"foo\": 1}\n\n        Will result in:\n\n            {\"foo\": \"1\"}\n\n    Args:\n        config_schema: an optional `ConfigSchema` to define the schema. This\n            takes precedence over a schema provided at object instantiation.\n        use_schema_values: an optional boolean to indicate whether the result\n            of passing the config through the schema should overwrite the existing\n            config values, meaning values are cast to types defined in the schema as\n            described above, and default values defined in the schema are used.\n\n    Returns:\n        the config values\n\n    Raises:\n        NoSchemaError: when validation is attempted but no schema has been provided\n    \"\"\"\n    if not (config_schema or self.config_schema):\n        raise NoSchemaError\n\n    schema: Type[ConfigSchema] = config_schema or self.config_schema  # type: ignore\n\n    validated_schema = schema(**self._config_dict)\n\n    if use_schema_values:\n        self._config_dict = validated_schema.dict()\n\n    return self._config_dict\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#retrieving-values","title":"Retrieving values","text":"<p>Once an instance of <code>ProjectConfig</code> has been created, values can be retrieved through:</p> <pre><code>&gt;&gt;&gt; config.get_option(\"foo\")\n'bar'\n</code></pre> <p>An optional second argument can be provided to <code>get_option</code> which will be returned if the given option isn't found:</p> <pre><code>&gt;&gt;&gt; config.get_option(\"baz\", \"default\")\n'default'\n</code></pre> <p><code>ProjectConfig</code> also exposes a <code>to_dict()</code> method to return all the config options:</p> <pre><code>&gt;&gt;&gt; config.to_dict()\n{'foo': 'bar'}\n</code></pre>"},{"location":"usage/#source-files","title":"Source files","text":"<p>By default, <code>maison</code> will look for a <code>pyproject.toml</code> file. If you prefer to look elsewhere, provide a <code>source_files</code> list to <code>ProjectConfig</code> and <code>maison</code> will select the first source file it finds from the list.</p> <pre><code>from maison import ProjectConfig\n\nconfig = ProjectConfig(\n  project_name=\"acme\",\n  source_files=[\"acme.ini\", \"pyproject.toml\"]\n)\n\nprint(config.config_path)\n#&gt; PosixPath(/path/to/acme.ini)\n</code></pre> <p>Currently only <code>.toml</code> and <code>.ini</code> files are supported. For <code>.ini</code> files, <code>maison</code> assumes that the whole file is relevant. For <code>pyproject.toml</code> files, <code>maison</code> assumes that the relevant section will be in a <code>[tool.{project_name}]</code> section. For other <code>.toml</code> files <code>maison</code> assumes the whole file is relevant.</p> <p>To verify which source config file has been found, <code>ProjectConfig</code> exposes a <code>config_path</code> property:</p> <pre><code>&gt;&gt;&gt; config.config_path\nPosixPath('/path/to/pyproject.toml')\n</code></pre> <p>The source file can either be a filename or an absolute path to a config:</p> <pre><code>from maison import ProjectConfig\n\nconfig = ProjectConfig(\n  project_name=\"acme\",\n  source_files=[\"~/.config/acme.ini\", \"pyproject.toml\"]\n)\n\nprint(config.config_path)\n#&gt; PosixPath(/Users/tom.jones/.config/acme.ini)\n</code></pre>"},{"location":"usage/#merging-configs","title":"Merging configs","text":"<p><code>maison</code> offers support for merging multiple configs. To do so, set the <code>merge_configs</code> flag to <code>True</code> in the constructor for <code>ProjectConfig</code>:</p> <pre><code>from maison import ProjectConfig\n\nconfig = ProjectConfig(\n  project_name=\"acme\",\n  source_files=[\"~/.config/acme.toml\", \"~/.acme.ini\", \"pyproject.toml\"],\n  merge_configs=True\n)\n\nprint(config.config_path)\n\"\"\"\n[\n  PosixPath(/Users/tom.jones/.config/acme.toml),\n  PosixPath(/Users/tom.jones/.acme.ini),\n  PosixPath(/path/to/pyproject.toml),\n]\n\"\"\"\n\nprint(config.get_option(\"foo\"))\n#&gt; \"bar\"\n</code></pre> <p>When merging configs, <code>maison</code> merges from right to left, ie. rightmost sources take precedence. So in the above example, if <code>~/config/.acme.toml</code> and <code>pyproject.toml</code> both set <code>nice_option</code>, the value from <code>pyproject.toml</code> will be returned from <code>config.get_option(\"nice_option\")</code>.</p>"},{"location":"usage/#search-paths","title":"Search paths","text":"<p>By default, <code>maison</code> searches for config files by starting at <code>Path.cwd()</code> and moving up the tree until it finds the relevant config file or there are no more parent paths.</p> <p>You can start searching from a different path by providing a <code>starting_path</code> property to <code>ProjectConfig</code>:</p> <pre><code>from maison import ProjectConfig\n\nconfig = ProjectConfig(\n  project_name=\"acme\",\n  starting_path=Path(\"/some/other/path\")\n)\n\nprint(config.config_path)\n#&gt; PosixPath(/some/other/path/pyproject.toml)\n</code></pre>"},{"location":"usage/#validation","title":"Validation","text":"<p><code>maison</code> offers optional schema validation using pydantic.</p> <p>To validate a configuration, first create a schema which subclasses <code>ConfigSchema</code>:</p> <pre><code>from maison import ConfigSchema\n\nclass MySchema(ConfigSchema):\n  foo: str = \"my_default\"\n</code></pre> <p><code>ConfigSchema</code> offers all the same functionality as the <code>pydantic</code> BaseModel</p> <p>Then inject the schema when instantiating a <code>ProjectConfig</code>:</p> <pre><code>from maison import ProjectConfig\n\nconfig = ProjectConfig(project_name=\"acme\", config_schema=MySchema)\n</code></pre> <p>To validate the config, simply run <code>validate()</code> on the config instance:</p> <pre><code>config.validate()\n</code></pre> <p>If the configuration is invalid, a <code>pydantic</code> <code>ValidationError</code> will be raised. If the configuration is valid, the validated values are returned.</p> <p>If <code>validate</code> is invoked but no schema has been provided, a <code>NoSchemaError</code> will be raised. A schema can be added after instantiation through a setter:</p> <pre><code>config.config_schema = MySchema\n</code></pre>"},{"location":"usage/#casting-and-default-values","title":"Casting and default values","text":"<p>By default, <code>maison</code> will replace the values in the config with whatever comes back from the validation. For example, for a config file that looks like this:</p> <pre><code>[tool.acme]\nfoo = 1\n</code></pre> <p>And a schema that looks like this:</p> <pre><code>class MySchema(ConfigSchema):\n  foo: str\n  bar: str = \"my_default\"\n</code></pre> <p>Running the config through validation will render the following:</p> <pre><code>config = ProjectConfig(project_name=\"acme\", config_schema=MySchema)\n\nprint(config.to_dict())\n#&gt; {\"foo\": 1}\n\nconfig.validate()\nprint(config.to_dict())\n#&gt; {\"foo\": \"1\", \"bar\": \"my_default\"}\n</code></pre> <p>If you prefer to keep the config values untouched and just perform simple validation, add a <code>use_schema_values=False</code> argument to the <code>validate</code> method.</p>"},{"location":"usage/#schema-precedence","title":"Schema precedence","text":"<p>The <code>validate</code> method also accepts a <code>config_schema</code> is an argument. If one is provided here, it will be used instead of a schema passed as an init argument.</p>"}]}